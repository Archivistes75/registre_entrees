---
title: "Archives municipales d'Avignon"
output: 
  flexdashboard::flex_dashboard:
    theme: readable
    vertical_layout: fill
    logo: logo_datactivist.png
    source_code: embed
    storyboard: true
#runtime: shiny

---

<style>

.nav-tabs-custom > .nav-tabs > li.active {
border-top-color: #E5555C;
}

body {
text-align: justify;
background: #f2f2f2;
}

.navbar-logo {
  margin-top: 4px;
}

.storyboard-nav .sbframelist {
margin: 0 auto;
width: 94%;
height: 50px;
overflow: hidden;
text-shadow: none;
margin-bottom: 8px;
}

.storyboard-nav .sbnext, .storyboard-nav .sbprev {
float: left;
width: 2%;
height: 45px;
font-size: 40px;
}

.column-box {
background-color: #f2f2f2;
border-color: #f2f2f2;
}

.storyboard-nav .sbframelist ul li.active {
  color: #fff;
  background: #B8B8B8;
}


</style>



```{r eval=FALSE, include=FALSE}
#<style> 

#.navbar {
#  background-color: #FAF3EE;
#  border-color: #1D3139;
#  color: #E5555C;   # couleur storyboard
#}
#.navbar-brand {
#color: #E5555C;
#}

#</style> 

# Paramètres des themes : https://github.com/rstudio/flexdashboard/blob/feature/logo-and-favicon/inst/rmarkdown/templates/flex_dashboard/resources/flexdashboard.css 
# Changer background couleur d'une seule box : https://stackoverflow.com/questions/54538451/how-to-add-background-colours-to-boxes-on-rmarkdown-flexdashboard
```


```{r setup, include=FALSE}
library(flexdashboard)
knitr::opts_chunk$set(echo = FALSE, eval = TRUE, message = FALSE, warning = FALSE,
collapse = TRUE,  fig.show = "hold", out.width = "100%")
```

```{r include=FALSE}
# Chargement des librairies
library(shiny)
library(tidyverse)
library(viridis) 
library(plotly) 
library(data.table) 
library(stringr)
library(ggplot2)
library(gganimate)
library(ggthemes)
library(hrbrthemes)
library(dygraphs) 
library(gmodels)
library(forcats)
library(e1071)
library(mlbench)
library(tm)
library(SnowballC)
library(wordcloud2)  # Version 0.2.2 nécessaire absolument. #devtools::install_github("lchiffon/wordcloud2")
library(htmlwidgets)
library(kableExtra)
library(gifski)


# Import base
avignon <- read_delim("Avignon_standardise.csv", ";")

# Format des données
str(avignon)


### Statistiques descriptives
summary(avignon)
table(avignon$nature)
table(avignon$modeEntree)

# Création d'une colonne où on récup l'année de la date d'entrée
avignon$dateYear <- format(as.Date(avignon$dateEntree, format="%d/%m/%Y"),"%Y")

# On remplace le mode d'entrée 'collecte' par 'collecte privée'
avignon$modeEntree <- str_replace_all(avignon$modeEntree, c("Collecte"="Collecte privée"))
```


Évolutions temporelles {data-icon="fa-chart-line"}
=====================================  


```{r}
dataset <- eventReactive(input$file1,{
   dataset <- read.csv(input$file1$datapath)
})
```


```{r, echo = FALSE}
fileInput("file1", "Veuillez importer la base de données au format csv.",
                    multiple = TRUE,
                    accept = c("text/csv",
                             "text/comma-separated-values,text/plain",
                             ".csv"))
```



Column {data-width=230}
-----------------------------------------------------------------------

**Quelques chiffres clés** :


### Numbers

```{r echo=FALSE}
# All icons here : https://ionicons.com/v2/cheatsheet.html or https://fontawesome.com/icons?d=gallery&p=2 
row <- nrow(avignon)
valueBox(row, caption="Archives entrées", color = "#CC0033", icon = "ion-android-archive")
```

### Numbers 2

```{r echo=FALSE}
t1 <- as.data.frame(table(avignon$dateYear))
t1$Var1 <- as.character(t1$Var1)  # étape intermédiaire sinon remplace les années par un ID de 1 à 24 
t1$Var1 <- as.integer(t1$Var1)

nYear <- tally(t1)
valueBox(nYear, caption="Années répertoriées", color = "#FF9933", icon = "ion-android-calendar")
```

### Part d'archives publiques

```{r echo=FALSE}
valueBox("63%", caption="Archives publiques", color = "#FFCC00", icon = "ion-loop")
#gauge(63, min = 0, max = 100, symbol = '%', gaugeSectors(danger = c(0, 100)))
```

### Part des supports électroniques

```{r echo=FALSE}
valueBox("27%", caption="Archives éléctroniques", color = "#339900", icon = "ion-android-desktop")
#gauge(63, min = 0, max = 100, symbol = '%', gaugeSectors(danger = c(0, 100)))
```

### Modes d'entrées

```{r echo=FALSE}
valueBox(9, caption="Modes d'entrée différents", color = "#009966", icon = "ion-ios-box") #ion-social-buffer pas mal aussi
```


### Nombre de séries

```{r echo=FALSE}
valueBox(853, caption="Séries", color = "#0066CC", icon = "ion-filing")  # à changer
```


Column {data-width=500}
-----------------------------------------------------------------------

### Nombre de documents entrés chaque année

```{r}
avignon$dateYear <- factor(avignon$dateYear, levels = c(min(avignon$dateYear):max(avignon$dateYear)))
t1 <- as.data.frame(table(avignon$dateYear))   # ces commandes permettent de récupérer des fréquences pour toutes les années même si aucune archive n'a été rentrée (freq=0 alors)

t11 <- stats::ts(t1$Freq, frequency=1, start=1989)

dygraph(t11) %>% dyRangeSelector() %>% dyOptions(stackedGraph = TRUE) %>% dySeries("V1", label = "Nombre d'entrées") %>%
  dyHighlight(highlightSeriesOpts = list(strokeWidth = 2))
```

### Nombre cumulé de documents par mode d'entrée depuis `r t1[1,1]`

```{r echo=FALSE}
### R.G n°1 : nb d'archives entrées par année selon le type

  # création du tableau des fréquences par année selon le mode d'entrée
t1bis <- subset(as.data.frame(table(avignon$dateYear, avignon$modeEntree)), Freq = 0) #fréquences
colnames(t1bis) <- c("dateYear", "modeEntree", "n") # mise en forme de la table
#str(t1bis)
t1bis$dateYear <- as.character(t1bis$dateYear)  # exploitabilité
t1bis$dateYear <- as.integer(t1bis$dateYear)

  # calcul des fréquences cumulées par année selon le mode d'entrée
t1bis <- t1bis %>% group_by(modeEntree) %>% mutate(count=cumsum(n)) # fréquences cumulées
  # plot
p <- t1bis %>%
     ggplot(aes(x=dateYear, y=count, fill=modeEntree,  
                text = paste("", "Mode d'entrée :", modeEntree, # customisation du texte à afficher
                             "\n", "Année :", dateYear,
                              "\n", count, "archives"), group=modeEntree))+
     geom_area(alpha=0.6 , size=.5, colour="white")+
     scale_fill_viridis(discrete = T, name="Mode d'entrée")+
     theme(legend.position = 'none')+
     theme_hc()+
   #  ggtitle("Nombre cumulé d'archives entrées par mode d'entrée depuis 1989") +
     labs(y = "Nombre cumulé d'entrées", x="Année de l'entrée")
ggplotly(p, source = "select", tooltip=c("text"))
```


Column {data-width=570} {.tabset}
-----------------------------------------------------------------------



### Nombre de documents entrés chaque année selon le type

```{r echo=FALSE}
  # plot
windowsFonts(A = windowsFont("Times New Roman"))  # on définit la police des labels (pour harmoniser la dashboard et reproduire le visu de ggplotly)

ggp <- ggplot(t1bis, aes(x=dateYear, y=n, colour=modeEntree)) +  
   geom_line(aes(x=dateYear, y=n), lwd=1) +
   labs(y = "Nombre d'entrées", x="Année de l'entrée") +
   theme_light() +
        theme(axis.title.y = element_text(family="A", size=rel(.9))) +
        theme(axis.title.x = element_text(margin = unit(c(rel(4), 0, 0, 0), "mm"), family="A", size=rel(.9))) +
        theme(strip.text = element_text(family="A", size=rel(.9), face="bold")) +
   transition_reveal(dateYear) +
  facet_wrap(vars(modeEntree)) +
  guides(colour = FALSE) 
gganimate::animate(ggp, 
                   renderer = gifski_renderer(loop = F))
#ggp
```

### Essai en plotly {data-padding=20}

```{r echo=FALSE}
  # plot
windowsFonts(A = windowsFont("Times New Roman"))  # on définit la police des labels (pour harmoniser la dashboard et reproduire le visu de ggplotly)

p <- ggplot(t1bis, aes(x=dateYear, y=n, colour=modeEntree,  
                text = paste("", "Mode d'entrée :", modeEntree, # customisation du texte à afficher
                              "\n", "Année :", dateYear,
                              "\n", n, "archives"), group=modeEntree)) +  
   geom_line(aes(x=dateYear, y=n), lwd=.8) +
   theme_light() +
   labs(y= "Nombre d'archives entrées", 
        x="Année de l'entrée") +
        theme(axis.title.y = element_text(family="A", size=rel(1))) +
        theme(axis.title.x = element_text(margin = unit(c(rel(4), 0, 0, 0), "mm"), family="A", size=rel(1))) +
        theme(strip.text = element_text(family="A", size=rel(1), face="bold")) +
   facet_wrap(vars(modeEntree)) +
   theme(legend.position = 'none') +
   guides(colour = FALSE)

ggplotly(p, source = "select", tooltip=c("text"))
```



Type et support des entrées {data-icon="fa-chart-bar"}
=====================================  

Column {data-width=400}
-------------------------------------

### Nature du support des archives entrées selon leur type

```{r}
nature <- c("Support physique", "Support électronique", "Support mixte")
avignon$natureSupport <- sample(nature, size = nrow(avignon), replace = TRUE)
  # On récupère un tableau des fréquences
t4 <- as.data.frame(table(avignon$natureSupport))
t4bis <- avignon %>% group_by(nature) %>% count(natureSupport)
t4bis <- na.omit(t4bis)

  # plot
t4bis <- t4bis %>% group_by(nature) %>% mutate(ypos = cumsum(n) - 0.5*n) %>% ungroup()
ggp2 <- ggplot(t4bis, aes(fill=natureSupport, y=n, x=nature,  
                text = paste("", nature, 
                             "\n", natureSupport,
                              "\n", n,"archives"), group=natureSupport)) + 
    geom_bar(position="stack", stat="identity") +
  #  geom_text(aes(y=ypos, label=n), vjust=1.3, color="white", size=5)+
    scale_fill_viridis(discrete = T, name="Nature du support", option="E", direction=-1) +
  #  ggtitle("Nature du support des archives entrées selon leur type") +
      labs(caption="Données non réelles pour la nature du support") +
    theme_ipsum() +
    xlab("") + ylab("Nombre d'entrées") +
        theme(axis.title.y = element_text(size=12))
ggplotly(ggp2, tooltip=c("text"))
```

### Nombre d'entrées selon le type et la nature
```{r}
t3 <- avignon %>% group_by(nature) %>% count(modeEntree)
t3 <- na.omit(t3)
  # plot
ggp3 <- ggplot(t3, aes(fill=modeEntree, y=n, x=nature,  
                text = paste("Nature :", nature, 
                             "\nType d'entrée :", modeEntree,
                              "\nCompte :", n,"archives"), group=modeEntree)) + 
    geom_bar(stat="identity", position=position_dodge()) +
    scale_fill_viridis_d(name="Type d'entrée", option = "D", direction = 1) +
  #  ggtitle("Nombre d'entrées selon le type et la nature") +
    theme_ipsum() +
    xlab("") + ylab("Nombre d'entrées") +
        theme(axis.title.y = element_text(size=12))
ggplotly(ggp3, tooltip=c("text"))
```



Column {data-width=600}{.tabset}
-------------------------------------

   **Répartition des archives selon le mode d'entrée**

### Sur toute la période 

```{r echo=FALSE}
### R.G n°4 : part de chaque mode d'entrée ds total archives entrées sur la période
    # création du tableau des fréquences par mode d'entrée
t2 <- as.data.frame(table(avignon$modeEntree))
colnames(t2) <- c("modeEntree", "Freq")

    # plot où on met la fréquence en pourcentage puis on réordonne par ordre décroissant
plot_t2 <- t2 %>% mutate(Freq = Freq/sum(Freq)) %>% 
  mutate(modeEntree = fct_reorder(modeEntree, Freq)) %>% 
  ggplot(aes(x=modeEntree, y=Freq,  
                text = paste("Mode d'entrée :", modeEntree, # customisation du texte à afficher
                              "\nPourcentage des archives :", round(Freq*100,0),"%"), group=modeEntree))+
    geom_bar(stat="identity", fill="#f68060", alpha=.6, width=.4) +
    coord_flip() +
    ylab("Pourcentage des archives entrées de 1989 à 2020") + xlab("Mode d'entrée") + 
 #  ggtitle("Répartition des archives selon le mode d'entrée") +
    theme_bw() +
    scale_y_continuous(labels = scales::percent_format())  # afficher des % sur la règle des y (abscisses car coord_flip)

ggplotly(plot_t2, tooltip=c("text"))
```


### Année par année {data-padding=65}

```{r echo=FALSE}

  # création du tableau des fréquences par mode d'entrée selon l'année
t2_bis <- avignon %>% group_by(dateYear) %>% count(modeEntree)

  # plot
plot2_t2 <- t2_bis %>% 
  ggplot(aes(x=modeEntree, y=n,  
             text = paste("Mode d'entrée :", modeEntree,
                              "\nNombre d'archives :", n), group=modeEntree)) +
  geom_bar(stat="identity", fill="#f68060", alpha=.6, width=.4) + 
  coord_flip() + 
  facet_wrap(vars(dateYear)) +
  ylab("Nombre d'entrées") + xlab("") +
  theme_bw() +
  theme(axis.text.y = element_text(size = rel(.8))) 

ggplotly(plot2_t2, tooltip=c("text"))
```





Nuages de mots {.storyboard data-icon="fa-cloud"}
=====================================  

### Domaine d'action du producteur

```{r out.width='100%', fig.align='left', include=FALSE}
data_wordcloud <- glimpse(avignon)
corpus = Corpus(VectorSource(data_wordcloud$activiteProd))

corpus = tm_map(corpus, PlainTextDocument) #Conversion to Lowercase
corpus = tm_map(corpus, tolower)
corpus = tm_map(corpus, removePunctuation) #Removing Punctuation

ajout_stopwords <- c("d'", "d", "article", "articles")
remix_stopwords <- c(ajout_stopwords, stopwords("french"))  # adding own undesired words to stopwords
corpus = tm_map(corpus, removeWords, c("cloth", remix_stopwords)) #Remove stopwords
corpus = tm_map(corpus, stripWhitespace) # Eliminate white spaces
corpus[[1]][1] 

DTM <- TermDocumentMatrix(corpus)
mat <- as.matrix(DTM)
f <- sort(rowSums(mat),decreasing=TRUE) 
dat <- data.frame(word = names(f),freq=f)
head(dat, 5)
```

```{r echo=FALSE}
wordcloud2(data=dat, size=1.6, col="grey", minRotation = -pi/6, maxRotation = -pi/6, rotateRatio = 1)
```


### Description du contenu de l'entrée

```{r include=FALSE}
data_wordcloud <- glimpse(avignon)
corpus2 = Corpus(VectorSource(data_wordcloud$descContenu))

corpus2 = tm_map(corpus2, PlainTextDocument) #Conversion to Lowercase
corpus2 = tm_map(corpus2, tolower)
corpus2 = tm_map(corpus2, removePunctuation) #Removing Punctuation
corpus2 = tm_map(corpus2, removeWords, c("cloth", remix_stopwords)) #Remove stopwords
corpus2 = tm_map(corpus2, stripWhitespace) # Eliminate white spaces

DTM2 <- TermDocumentMatrix(corpus2)
mat2 <- as.matrix(DTM2)
f2 <- sort(rowSums(mat2),decreasing=TRUE)
dat2 <- data.frame(word = names(f2),freq=f2)
```

```{r echo=FALSE, fig.align='bottom'}
wordcloud2(data=dat2, size=2, col="#0066CC", minRotation = -pi/6, maxRotation = -pi/6, rotateRatio = 0)
```


### Un mot de fin ?

```{r out.width='120%', fig.align='top', background="#FAF3EE"}
knitr::include_graphics(here::here("./Dashboard_viz/wc_blanc.png"))
```


Les données {data-icon="fa-table"}
=====================================  


```{r}
DT::datatable(avignon, options=list(pageLength=25, searching=T))
```


À propos du standard {data-icon="fa-clipboard-list"}
=====================================  


Column {data-width=500} 
-------------------------------------

### {data-padding=20 .column-box }
 
En 2018, 86 kilomètres de documents et plus de 16000Go de données sont venus enrichir les collections des **services publics d'archives français** (données du *service interministériel des archives de France*).

Dans une optique de gestion et de suivi de leurs fonds, les services d'archives consignent chaque entrée d'archives à partir de renseignements sommaires permettant d’identifier et de retracer toutes les arrivées de nouveaux documents (provenance, date d'arrivée dans le service, volume...) : c'est le **registre des entrées**.

Il est généralement directement tenu au sein d'un système d'information dédié aux archives (le *SIA*), mais il peut également être réalisé avec un tableur voire sur un cahier.

<br>

Dans son **cadre stratégique commun de modernisation des archives**, la *délégation interministérielle aux archives de France* mentionne dans les objectifs 2020-2024 :

    Objectif 1.4 : Numériser les archives et rendre les archives numériques aisément consultables et exploitables. Il conviendra également de généraliser l’open data dans les services d’archives de l’État et de recommander ce modèle aux services territoriaux d’archives. La création d'un schéma de données permet de standardiser la diffusion des données produites par les services d'archives. Cette standardisation est impérative pour les ré-utilisateurs car elle permet de faciliter la découverte des jeux de données et de les utiliser, notamment en simplifiant l'alignement à différentes échelles (utilisation sur des échelles locales ou nationales).
    
<br>

Ainsi, en quelques mois, une équipe composée de représentants du SIAF, de l'AAF et de Datactivist ont travaillé pour mettre au point un standard pour les données des **registres d'entrées**. Ce dernier n'a pas de caractère réglementaire mais son utilisation est recommandée dès lors qu'une réutilisation ou une comparaison des données est envisagée.




Column {data-width=650}
-------------------------------------


### {data-padding=20}

> Les colonnes à caractère **obligatoire** qui composent le standard :


`ID`

- **titre** : Identifiant unique de chaque entrée

- **description** : Identifiant unique de chaque entrée sous la forme : l'identifiant du service archives, année d'entrée et un identifiant unique (numéro incrémental, identifiant technique...).


`nomArch`

- **titre** : Nom du service archives 

- **description** : Nom sous forme textuelle du service d'archives dans lequel sont entrées les archives


`dateEntree`

- **titre** : Date d'entrée 

- **description** : Date à laquelle les documents sont entrés dans le service d'archives au format ISO8601



`nature`

- **titre** : Nature juridique des documents entrés

- **description** : Permet d'identifier la nature juridique des archives


`modeEntree`

- **titre** : Modalité d'entrée

- **description** : Permet d'identifier le mode d'entrée des archives


`servProd`

- **titre** : Service producteur

- **description** : Permet d'identifier la personne physique ou morale qui a produit les documents


`typeProd`

- **titre** : Fonction du producteur

- **description** : permet d'identifier la fonction du producteur, liste établie à partir des éléments du SIAF 


`activiteProd`

- **titre** : Domaine ou thématique d'action du producteur

- **description** : Permet d'identifier le domaine d'activité du producteur, liste établie à partir des éléments du SIAF 


`descContenu`

- **titre** : Description du contenu

- **description** : Permet de décrire le contenu des archives de l'entrée


`natureSupport`

- **titre** : Nature du support matériel des documents

- **description** : Permet d'indiquer de façon macro la typologie de support des documents


<br>

> Les colonnes à caractère **non obligatoire** qui composent le standard :


`coteArch`

- **titre** : Cotation

- **description** : Identifiant de l'entrée d’archives et correspondant à sa place dans le cadre de classement (série et sous-série)

`orgaVers`

- **titre** : Organisation qui verse l'entrée

- **description** : Nom de l'organisation qui a versé l'entrée, distincte du service qui a produit les entrées dans l'organisation.



`servVers`

- **titre** : Service qui verse l'entrée

- **description** : permet d'identifier la personne physique ou morale qui a transféré les documents



`orgaProd`

- **titre** : Organisation productrice de l'entrée

- **description** : nom de l'organisation qui a produit l'entrée, distincte du service qui a produit les entrées dans l'organisation. 

`dateExD`

- **titre** : Date extrème de début

- **description** : Date du plus vieux document d'archives format AAAA



`dateExF`

- **titre** : Date extrème de fin

- **description** : Date du plus récent document d'archives format AAAA

`mlEntree`

- **titre** : Métrage linéaire de l'entrée

- **description** : Volume en mètre linéaire de l'entrée


`nbreArt`

- **titre** : Nombre d'articles

- **description** : Permet d'indiquer le nombre d'articles d'une entrée



`volElec`

- **titre** : Volume d'archives électroniques de l'entrée

- **description** : Correspond à la volumétrie de fichiers électroniques présents dans l'entrée en Go


`objElec`

- **titre** : Nombre d'objets électroniques 

- **description** : Permet d'indiquer le nombre d'objets électroniques d'une entrée



<br>

> En résumé ce sont **20 variables** dont :

  + 4 quantitatives
  + 3 dates
  + 13 qualitatives
