---
title: "Archives municipales d'Avignon"
output: 
  flexdashboard::flex_dashboard:
    theme: bootstrap
    social: menu
  #  orientation: rows
    vertical_layout: fill
    logo: datactivist2.png
---

```{r setup, include=FALSE}
library(flexdashboard)
knitr::opts_chunk$set(echo = FALSE, eval = TRUE, message = FALSE, warning = FALSE,
collapse = TRUE,  fig.show = "hold", out.width = "100%")
```

```{r include=FALSE}
# Chargement des librairies
library(shiny)
library(tidyverse)
library(viridis) 
library(plotly) 
library(data.table) 
library(stringr)
library(ggplot2)
library(gganimate)
library(ggthemes)
library(hrbrthemes)
library(dygraphs) 
library(gmodels)
library(forcats)
library(e1071)
library(mlbench)
library(tm)
library(SnowballC)
library(wordcloud2)  # Version 0.2.2 nécessaire absolument. #devtools::install_github("lchiffon/wordcloud2")
library(htmlwidgets)


# Import base
avignon <- read_delim("Avignon_standardise.csv", ";")

# Format des données
str(avignon)


### Statistiques descriptives
summary(avignon)
table(avignon$nature)
table(avignon$modeEntree)

# Création d'une colonne où on récup l'année de la date d'entrée
avignon$dateYear <- format(as.Date(avignon$dateEntree, format="%d/%m/%Y"),"%Y")

# On remplace le mode d'entrée 'collecte' par 'collecte privée'
avignon$modeEntree <- str_replace_all(avignon$modeEntree, c("Collecte"="Collecte privée"))
```

Page 1 {data-orientation=columns}
=====================================  


```{r}
dataset <- eventReactive(input$file1,{
   dataset <- read.csv(input$file1$datapath)
})
```


```{r, echo = FALSE}
fileInput("file1", "Veuillez importer la base de données au format csv.",
                    multiple = TRUE,
                    accept = c("text/csv",
                             "text/comma-separated-values,text/plain",
                             ".csv"))
```



Column {data-width=250}
-----------------------------------------------------------------------

**Quelques chiffres clés** :

### Numbers

```{r echo=FALSE}
# All icons here : https://ionicons.com/v2/cheatsheet.html
row <- nrow(avignon)
valueBox(row, caption="Archives entrées", color = "#CC0033", icon = "ion-android-archive")
```

### Numbers 2

```{r echo=FALSE}
t1 <- as.data.frame(table(avignon$dateYear))
t1$Var1 <- as.character(t1$Var1)  # étape intermédiaire sinon remplace les années par un ID de 1 à 24 
t1$Var1 <- as.integer(t1$Var1)

nYear <- tally(t1)
valueBox(nYear, caption="Années répertoriées", color = "#FF9933", icon = "ion-android-calendar")
```

### Part d'archives publiques

```{r echo=FALSE}
valueBox("36%", caption="Archives publiques", color = "#FFCC00", icon = "ion-android-contact")
#gauge(63, min = 0, max = 100, symbol = '%', gaugeSectors(danger = c(0, 100)))
```

### Part des supports électroniques

```{r echo=FALSE}
valueBox("67%", caption="Archives éléctroniques", color = "#339900", icon = "ion-android-desktop")
#gauge(63, min = 0, max = 100, symbol = '%', gaugeSectors(danger = c(0, 100)))
```

### Nombre de séries

```{r echo=FALSE}
valueBox(853, caption="Séries", color = "#0066CC", icon = "ion-ios-filing")
```


Column {data-width=600}
-----------------------------------------------------------------------

### Nombre de documents entrés chaque année

```{r}
avignon$dateYear <- factor(avignon$dateYear, levels = c(min(avignon$dateYear):max(avignon$dateYear)))
t1 <- as.data.frame(table(avignon$dateYear))   # ces commandes permettent de récupérer des fréquences pour toutes les années même si aucune archive n'a été rentrée (freq=0 alors)

t11 <- stats::ts(t1$Freq, frequency=1, start=1989)

dygraph(t11) %>% dyRangeSelector() %>% dyOptions(stackedGraph = TRUE) %>% dySeries("V1", label = "Nombre d'entrées") %>%
  dyHighlight(highlightSeriesOpts = list(strokeWidth = 2))
```

### Nombre cumulé de documents par mode d'entrée depuis `r t1[1,1]`

```{r echo=FALSE}
### R.G n°1 : nb d'archives entrées par année selon le type

  # création du tableau des fréquences par année selon le mode d'entrée
t1bis <- subset(as.data.frame(table(avignon$dateYear, avignon$modeEntree)), Freq = 0) #fréquences
colnames(t1bis) <- c("dateYear", "modeEntree", "n") # mise en forme de la table
#str(t1bis)
t1bis$dateYear <- as.character(t1bis$dateYear)  # exploitabilité
t1bis$dateYear <- as.integer(t1bis$dateYear)

  # calcul des fréquences cumulées par année selon le mode d'entrée
t1bis <- t1bis %>% group_by(modeEntree) %>% mutate(count=cumsum(n)) # fréquences cumulées
  # plot
p <- t1bis %>%
     ggplot(aes(x=dateYear, y=count, fill=modeEntree,  
                text = paste("Mode d'entrée :", modeEntree, # customisation du texte à afficher
                              "\nAnnée :", dateYear,
                              "\n", count, "archives"), group=modeEntree))+
     geom_area(alpha=0.6 , size=.5, colour="white")+
     scale_fill_viridis(discrete = T, name="Mode d'entrée")+
     theme(legend.position = 'none')+
     theme_hc()+
   #  ggtitle("Nombre cumulé d'archives entrées par mode d'entrée depuis 1989") +
     labs(y = "Nombre cumulé d'entrées", x="Année de l'entrée")
ggplotly(p, source = "select", tooltip=c("text"))
```


Column {data-width=450}{.tabset}
-----------------------------------------------------------------------


   **Répartition des archives selon le mode d'entrée**

### Sur toute la période

```{r echo=FALSE}
### R.G n°4 : part de chaque mode d'entrée ds total archives entrées sur la période
    # création du tableau des fréquences par mode d'entrée
t2 <- as.data.frame(table(avignon$modeEntree))
colnames(t2) <- c("modeEntree", "Freq")

    # plot où on met la fréquence en pourcentage puis on réordonne par ordre décroissant
plot_t2 <- t2 %>% mutate(Freq = Freq/sum(Freq)) %>% 
  mutate(modeEntree = fct_reorder(modeEntree, Freq)) %>% 
  ggplot(aes(x=modeEntree, y=Freq,  
                text = paste("Mode d'entrée :", modeEntree, # customisation du texte à afficher
                              "\nPourcentage des archives :", round(Freq*100,0),"%"), group=modeEntree))+
    geom_bar(stat="identity", fill="#f68060", alpha=.6, width=.4) +
    coord_flip() +
    ylab("Pourcentage des archives entrées de 1989 à 2020") + xlab("Mode d'entrée") + 
 #  ggtitle("Répartition des archives selon le mode d'entrée") +
    theme_bw() +
    scale_y_continuous(labels = scales::percent_format())  # afficher des % sur la règle des y (abscisses car coord_flip)

ggplotly(plot_t2, tooltip=c("text"))
```


### Année par année {.no-mobile}

```{r echo=FALSE, out.width = "70%"}
    # création du tableau des fréquences par mode d'entrée selon l'année
t2_individual <- as.data.frame(table(avignon$modeEntree, avignon$dateYear))
colnames(t2_individual) <- c("modeEntree", "dateYear", "Freq")
  # plot
 t2_individual %>% ggplot(aes(x=modeEntree, y=Freq)) +
  geom_bar(stat="identity", fill="#f68060", alpha=.6, width=.4) + coord_flip() + 
  facet_wrap(vars(dateYear)) +
  ylab("Nombre d'entrées") + xlab("Mode d'entrée") + # ggtitle("Fréquence des entrées par année selon le type") +
#   ggtitle("Répartition des archives selon le mode d'entrée par année") +
  theme_bw()

```



Page 2 {data-orientation=columns}
=====================================  

Column {data-width=400}
-------------------------------------

### Nature du support des archives entrées selon leur type

```{r}
nature <- c("Support physique", "Support électronique", "Support mixte")
avignon$natureSupport <- sample(nature, size = nrow(avignon), replace = TRUE)
  # On récupère un tableau des fréquences
t4 <- as.data.frame(table(avignon$natureSupport))
t4bis <- avignon %>% group_by(nature) %>% count(natureSupport)
t4bis <- na.omit(t4bis)

  # plot
t4bis <- t4bis %>% group_by(nature) %>% mutate(ypos = cumsum(n) - 0.5*n) %>% ungroup()
ggplot(t4bis, aes(fill=natureSupport, y=n, x=nature)) + 
    geom_bar(position="stack", stat="identity") +
    geom_text(aes(y=ypos, label=n), vjust=1.3, color="white", size=5)+
    scale_fill_viridis(discrete = T, name="Nature du support") +
  #  ggtitle("Nature du support des archives entrées selon leur type") +
      labs(caption="Données non réelles pour la nature du support") +
    theme_ipsum() +
    xlab("") + ylab("Nombre d'entrées") +
        theme(axis.title.y = element_text(size=12))
```

### Nombre d'entrées selon le type et la nature
```{r}
t3 <- avignon %>% group_by(nature) %>% count(modeEntree)
t3 <- na.omit(t3)
  # plot
ggp2 <- ggplot(t3, aes(fill=modeEntree, y=n, x=nature,  
                text = paste("Nature :", nature, 
                             "\nType d'entrée :", modeEntree,
                              "\nCompte :", n,"archives"), group=modeEntree)) + 
    geom_bar(stat="identity", position=position_dodge()) +
    scale_fill_viridis_d(name="Type d'entrée", option = "D", direction = 1) +
  #  ggtitle("Nombre d'entrées selon le type et la nature") +
    theme_ipsum() +
    xlab("") + ylab("Nombre d'archives") +
        theme(axis.title.y = element_text(size=12, face="italic"))
ggplotly(ggp2, tooltip=c("text"))
```



Column {data-width=600}
-------------------------------------



### Nombre de documents entrés chaque année selon le type

```{r echo=FALSE}
  # plot
ggp <- ggplot(t1bis, aes(x=dateYear, y=n, colour=modeEntree)) +  
   geom_line(aes(x=dateYear, y=n), lwd=1) +
   labs(y = "Nombre d'archives entrées", x="Année de l'entrée") +
        theme(plot.title = element_text(face = "bold")) +
        theme(axis.title.y = element_text(size=12)) +
        theme(axis.title.x = element_text(size=12)) +
#   transition_reveal(dateYear) +
   facet_wrap(vars(modeEntree)) +
   theme_light() + guides(colour = FALSE) 
#animate(ggp)
ggp
```




Data {.storyboard}
=====================================  


### Les données

```{r echo=FALSE}
knitr::kable(avignon, format = "html") %>%
kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),fixed_thead = list(enabled = T, background = "lightgrey"))
```

### Wordcloud

```{r include=FALSE}
data_wordcloud <- glimpse(avignon)
corpus = Corpus(VectorSource(data_wordcloud$activiteProd))

corpus = tm_map(corpus, PlainTextDocument) #Conversion to Lowercase
corpus = tm_map(corpus, tolower)
corpus = tm_map(corpus, removePunctuation) #Removing Punctuation
corpus = tm_map(corpus, removeWords, c("cloth", stopwords("french"))) #Remove stopwords
corpus = tm_map(corpus, stripWhitespace) # Eliminate white spaces
corpus[[1]][1] 

DTM <- TermDocumentMatrix(corpus)
mat <- as.matrix(DTM)
f <- sort(rowSums(mat),decreasing=TRUE)  #moment d'ajouter ville !
dat <- data.frame(word = names(f),freq=f)
head(dat, 5)
```

```{r echo=FALSE}
wordcloud2(data=dat, size=1.6, col="grey", minRotation = -pi/6, maxRotation = -pi/6, rotateRatio = 1)
```

### WC 2

```{r include=FALSE}
data_wordcloud <- glimpse(avignon)
corpus2 = Corpus(VectorSource(data_wordcloud$descContenu))

corpus2 = tm_map(corpus2, PlainTextDocument) #Conversion to Lowercase
corpus2 = tm_map(corpus2, tolower)
corpus2 = tm_map(corpus2, removePunctuation) #Removing Punctuation
corpus2 = tm_map(corpus2, removeWords, c("cloth", stopwords("french"))) #Remove stopwords
corpus2 = tm_map(corpus2, stripWhitespace) # Eliminate white spaces

DTM2 <- TermDocumentMatrix(corpus2)
mat2 <- as.matrix(DTM2)
f2 <- sort(rowSums(mat2),decreasing=TRUE)
dat2 <- data.frame(word = names(f2),freq=f2)
```

```{r echo=FALSE}
library(wordcloud2)
letterCloud(data=dat, word="SIAF", backgroundColor="pink", color="red")
```

### descContenu sans letter

```{r}
wordcloud2(data=dat2, size=1.6, col="red", minRotation = -pi/6, maxRotation = -pi/6, rotateRatio = 1)
```

### descContenu avec letter

```{r}
letterCloud(data=dat2, word="O")
```




Nuages de mots
=====================================  

### Hope il marche

```{r}
letterCloud(data=dat2, word="SIAF", color=rep_len(c("#1D3139","#E5555C"), nrow(dat2)), backgroundColor="#FAF3EE")

```

## Essai truc avec 2 diez


```{r echo=FALSE}
wordcloud2(data=dat, size=1.6, col="grey", minRotation = -pi/6, maxRotation = -pi/6, rotateRatio = 1)
```
